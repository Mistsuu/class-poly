#include <stdlib.h>
#include <stdio.h>
#include "ff_poly.h"
#include "ecurve.h"
#include "velu.h"

/*
    Copyright 2012 Andrew V. Sutherland

    This file is part of classpoly.

    classpoly is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    classpoly is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with classpoly.  If not, see <http://www.gnu.org/licenses/>.
*/

#define MAX_RETRIES		100			// number of times to attempt to find a point with order ell (cannot afford to fail)
#define MIN_RETRIES		3			// number of times to attempt to find a point with maximal order in the ell-Sylow

/*
	The function velu_isogeny constructs a "random" ell-isogeny using Velu's formulas.
	IMPORTANT: the distribution will be uniform only in the case where the ell-Sylow is cyclic, or its order is a square.
	Fortunately this applies in the situation where we are using the isogeny-volcano algorithm for computing modular polynomials.
	We could easily remedy this defect by computing a basis for the ell-sylow subgroup (the code to do this is available in ecurve.c)

	We use the version of Velu's formulas that appear in the appendix of Galbraith's 
	"Constructing iosogenies between elliptic curves over finite fields",
	Journal of Computational Mathematics, London Mathematical Society, 1999.
*/

void velu_isogeny (ff_t *J1, ff_t J0, long t, long ell)
{
	static ff_t *x, *y;
	static ecp_jc_t *P;
	static int init;
	ff_t f[4], g[4];
	register ff_t t0,t1,t2,t3,tsum,wsum;
	long e,m,m1,m2,N;
	register int i,j;

	if ( ! init ) { x = malloc (VELU_MAX_ELL/2 * sizeof(*x)); y = malloc(VELU_MAX_ELL/2 *sizeof(*y));  P = malloc (VELU_MAX_ELL/2 * sizeof (*P)); init = 1; }
	if ( ell > VELU_MAX_ELL ) { err_printf ("ell=%ld exceeds VELU_MAX_ELL=%d\n", ell, VELU_MAX_ELL); abort (); }
	
	N = _ff_p+1-t;
	// factor N as m*e where m is the order of the p-Sylow
	for ( e = N/ell, m = ell ; e*m == N ; e /= ell, m *= ell );
	m /= ell;  e = N / m;
	if ( m==1 ) { err_printf ("Error in velu_isogeny, curve with j-invariant %ld, trace %ld over F_%ld has trivial %ld-Sylow subgroup, N=%ld\n", _ff_get_ui(J0), t, _ff_p, ell, N); abort (); }

	ecurve_from_jinv_trace (f,J0,t);

	// if the ell-Sylow has order <= ell^2, don't bother to compute a basis, we can easily get a uniformly random point of order ell ourselves
	if ( m <= ell*ell ) {
		for ( i = 0 ; i < MAX_RETRIES ; i++ ) {
			ecurve_random_point(x,y,f);
			ecurve_AJC_exp_ui (P,x[0],y[0],e,f[1]);
			if ( ! ecurve_JC_id (P) ) break;
		}
		if ( i == MAX_RETRIES ) { err_printf ("Error, couldn't find a point of order ell=%ld on curve with j-invariant %ld and trace %ld over F_%ld (trace wrong?!)\n", ell, _ff_get_ui(J0), t, _ff_p); abort (); }
		// We should have a random non-trivial point in the ell-Sylow now, which we may exponentiate to get a point of order ell.
		// Provided the ell-Sylow is cyclic or has square order, this will yield a uniformly random point of order ell (but otherwise it won't!).
		// Just in case the trace is wrong, we give up if we can't seem to get a point of order ell.
		for ( j = 0 ; j < 64 ; j++ ) { ecurve_JC_exp_ui (P+1,P,ell,f[1]); if ( ecurve_JC_id(P+1) ) break; P[0] = P[1]; }
		if ( j == 64 )  { err_printf ("Error, couldn't find a point of order ell=%ld on curve with j-invariant %ld and trace %ld over F_%ld (trace wrong?!)\n", ell, _ff_get_ui(J0), t, _ff_p); abort (); }
	} else {
		// Get a basis for the ell-Sylow.  We assume the basis elements are uniformly distributed over the elements of maximal order in the subgroups they generate.
		ecurve_p_basis (P,&m1,P+1,&m2,ell,N,f);
		if ( m1 > ell ) ecurve_JC_exp_ui (P,P,m1/ell,f[1]);
		if ( m2 > ell ) ecurve_JC_exp_ui (P+1,P+1,m2/ell,f[1]);
		ecurve_JCJC (P,P+1,f[1]);
	}

	ecurve_JC_to_A_parallel (x, y, P, 1);
	dbg_printf ("Computing %ld-isogeny with kernel generated by the point (%ld,%ld) on the curve y^2=x^3+%ld*x+%ld over F_%ld with j-invariant %ld, trace %ld\n", ell, _ff_get_ui(x[0]), _ff_get_ui(y[0]), _ff_get_ui(f[1]), _ff_get_ui(f[0]), _ff_p, _ff_get_ui(J0), t);
	
	// Enumerate points in the subgroup of order ell (half of them) and apply Velu's formula to construct an ell-isogeny, as in Alg 6.4 of BLS11
	if ( ecurve_AJC_steps (P, x[0], y[0], (ell-1)/2, f[1]) != (ell-1)/2 ) {err_printf ("Error in velu_isogeny, couldn't compute %ld points in subgroup of order %ld\n", (ell-1)/2, ell); abort(); }
	ecurve_JC_to_A_parallel (x, y, P, (ell-1)/2);
	_ff_set_zero(tsum); _ff_set_zero(wsum);
	// compute tsum = \sum_i (6 x[i]^2 + 2 f[1]) and wsum = \sum_i (4 y[1]^2 + (6 x[i]^2 + 2f[1]) x[i])
	for ( i = 0 ; i < (ell-1)/2 ; i++ ) {
		_ff_square(t0,x[i]); _ff_triple(t1,t0); _ff_addto(t1,f[1]); _ff_add(t0,t1,t1); _ff_addto(tsum,t0);
		_ff_add(t1,y[i],y[i]); _ff_square(t2,t1); _ff_mult(t3,x[i],t0); _ff_addto(t2,t3); _ff_addto(wsum,t2);
	}
	_ff_set_one(g[3]); _ff_set_zero(g[2]);
	// compute g[1] = f[1] - 5*tsum and g[0] = f[0] - 7*wsum
	_ff_set_ui (t1,5); _ff_mult(t0,t1,tsum); _ff_sub(g[1],f[1],t0); _ff_set_ui (t1,7); _ff_mult(t0,t1,wsum); _ff_sub(g[0],f[0],t0);
	ecurve_to_jinv (J1,g);
	dbg_printf ("%ld-isogenous curve y^2=x^3+%ld*x+%ld over F_%ld has j-invariant %ld\n", ell, _ff_get_ui(g[1]), _ff_get_ui(g[0]), _ff_p,  _ff_get_ui(*J1));
}

int velu_verify_Sylow_cyclic (ff_t J, long t, long ell)
{
	ff_t f[4], x, y;
	long e, N;
	int i;
	
	N = _ff_p+1-t;
	e = N/ell;
	if ( ell*e != N ) { err_printf ("Error in velu_isogeny, curve with j-invariant %ld, trace %ld over F_%ld has trivial %ld-Sylow subgroup, N=%ld\n", _ff_get_ui(J), t, _ff_p, ell, N); abort (); }
	ecurve_from_jinv_trace (f,J,t);
	for ( i = 0 ; i < MIN_RETRIES ; i++ ) {
		ecurve_random_point(&x,&y,f);
		if ( ecurve_exp_ui (&x,&y,x,y,e,f[1]) ) return 1;		// return value of 1 means the result is non-trival
	}
	return 0;
}
